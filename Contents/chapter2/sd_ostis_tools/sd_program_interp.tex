\begin{SCn}
	
\scnsectionheader{\currentname}
\scnstartsubstruct

\scnheader{программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scnidtf{программный вариант реализации базового интерпретатора логико-семантических моделей компьютерных систем}
\scnidtf{вариант реализации базового интерпретатора логико-семантических моделей компьютерных систем на традиционных компьютерах с архитектурой фон Неймана}
\scnsuperset{web-ориентированный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scnaddlevel{1}
	\scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем предполагающий взаимодействие пользователей с системой посредством сети Интернет}
	\scnsubset{многопользовательский вариант реализации платформы интерпретации sc-моделей компьютерных систем}
	\scnhaselement{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scnaddlevel{-1}

\scnheader{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scnrelfromset{декомпозиция программной системы}{Реализация sc-памяти;Реализация интерпретатора sc-моделей пользовательских интерфейсов;Реализация scp-интерпретатора}
\scnexplanation{Текущий \textit{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем} является web-ориентированным, то есть с точки зрения современной архитектуры каждая ostis-система представляет собой web-сайт доступный онлайн посредством обычного браузера. Такой вариант реализации обладает очевидным преимуществом -- доступ к системе возможен из любой точки мира, где есть Интернет, при этом для работы с системой не требуется никакого специализированного программного обеспечения. С другой стороны, такой вариант реализации обеспечивает возможность параллельной работы с системой нескольких пользователей.

В то же время, взаимодействие клиентской и серверной части организовано таким образом, что web-интерфейс может быть легко заменен на настольный или мобильный интерфейс, как универсальный, так и специализированный.

Данный вариант реализации распространяется под open-source лицензией, для хранения исходных текстов используется хостинг Github и коллективная учетная запись ostis-dev.

Реализация является кроссплатформенной и может быть собрана под ОС семейства Windows и Linux.
}

\scnheader{Реализация sc-памяти}
\scnidtf{sc-machine}
\scntext{основной репозиторий исходных текстов}{https://github.com/ostis-dev/sc-machine.git}
\scnrelfromlist{компонент программной системы}{Реализация sc-хранилища и механизма доступа к нему;Реализация базового набора платформенно-зависимых sc-агентов;Реализация подсистемы взаимодействия с внешней средой с использованием протокола SCTP;Реализация подсистемы взаимодействия с внешней средой с использованием протоколов на основе формата JSON;Реализация вспомогательных инструментальных средств в рамках реализации sc-памяти}
\scntext{программная документация}{http://ostis-dev.github.io/sc-machine/}
\scnrelfromlist{используемый язык программирования}{C;C++;Python}

\scnheader{Реализация sc-хранилища и механизма доступа к нему}
\scnrelfrom{компонент программной системы}{Реализация файловой памяти ostis-системы}
\scntext{принципы реализации}{В рамках данной программной реализации \textit{sc-хранилища} \scnbigspace \textit{sc-память} моделируется в виде набора \textit{сегментов} фиксированного размера ($2^{16}-1=65535$ \textit{sc-элементов}). Максимально возможный набор сегментов ограничивается настройками программной реализации sc-хранилища (в настоящее время по умолчанию установлено количество $2^{16}-1=65535$ сегментов). Таким образом, технически максимальное количество sc-элементов в текущей реализации составляет около $4.3 \times 10^{9}$ sc-элементов.

По умолчанию все сегменты физически располагаются в оперативной памяти, если объема памяти не хватает, то предусмотрен механизм выгрузки части сегментов на жесткий диск.

Каждый сегмент состоит из набора структур данных, описывающих \textit{sc-элементы} (далее будем говорить, что сегмент состоит из sc-элементов). Независимо от типа sc-элемент имеет фиксированный размер (в текущий момент -- 56 байт), что обеспечивает удобство их хранения. Таким образом, максимальный размер базы знаний в текущий момент в физическом выражении может достигнуть 223 Гб (без учета содержимого \textit{внутренних файлов ostis-системы}).

Каждый sc-элемент в текущей реализации может быть однозначно задан его адресом (sc-адресом), состоящим из номера сегмента и номера sc-элемента в рамках сегмента.

Каждый sc-элемент описывается его синтаксическим типом (меткой), а также независимо от типа указывается sc-адрес первой входящей sc-дуги и первой выходящей sc-дуги (могут быть пустыми, если таких sc-дуг нет). Далее в зависимости от типа указывается либо содержимое (для внутреннего файла, может быть пустым, если sc-узел не является знаком файла), либо спецификация sc-дуги.

В текущей реализации набор синтаксических типов sc-элементов  включает в себя следующие признаки:
\begin{scnitemize}
	\item принадлежность одному из базовых классов sc-элементов, т.е. классов уровня Алфавита SC-кода (sc-узел, sc-дуга общего вида, sc-дуга принадлежности, sc-ребро, sc-ссылка (внутренний файл ostis-системы));
	\item признак константности/переменности (для всех sc-элементов);
	\item признак позитивности/негативности/нечеткости (для sc-дуг принадлежности);
	\item признак стационарности/нестационарности (для sc-дуг принадлежности);	
	\item принадлежность одному из следующих классов сущностей -- \textit{sc-структура}, \textit{sc-связка}, \textit{ролевое отношение}, \textit{неролевое отношение}, \textit{sc-класс}, \textit{абстрактная терминальная сущность}, \textit{материальная сущность}.
\end{scnitemize}

Спецификация sc-дуги включает указание sc-адресов начального и конечного sc-элементов, инцидентных данной sc-дуге, а также sc-адреса следующей и предыдущей sc-дуг, входящих в конечный для данной sc-дуги sc-элемент, и sc-адреса следующей и предыдущей sc-дуг, выходящих из начального для данной sc-дуги sc-элемента. 

Таким образом каждый sc-элемент (в том числе, sc-дуга) не хранит список связанных с ним sc-элементов, а хранит адреса одной выходящей и одной входящей дуги, каждая из которых в свою очередь хранит адреса следующей и предыдущей дуг в списке исходящих и входящих для соответствующих элементов. Это позволяет сделать размер всех sc-элементов фиксированным.
	
Каждый sc-узел в текущей реализации может иметь содержимое (может стать \textit{внутренним файлом ostis-системы}). Под содержимое отводится 48 байт (объем, эквивалентный спецификации sc-дуги). Если объем содержимого не превышает это значение, то содержимое хранится прямо в sc-элементе в виде набора байт. В противном случае оно помещается в специальным образом организованную файловую память (за ее организацию отвечает отдельный модуль платформы, который в общем случае может быть устроен по-разному), а в содержимое sc-узла записывается уникальный идентификатор, позволяющий быстро найти нужное содержимое в файловой памяти.
}
\scnaddlevel{1}
	\scnnote{sc-ребра в текущий момент хранятся так же, как sc-дуги, то есть имеют начальный и конечный sc-элементы, отличие только в типе (sc-edge вместо sc-arc). Это приводит к ряду неудобств при обработке, но sc-ребра используются пока достаточно редко.}
\scnaddlevel{-1}

\scnheader{Реализация базового набора платформенно-зависимых sc-агентов}

\scnheader{SCTP}
\scnidtf{Semantic Code Transfer Protocol}
\scnrelboth{аналогия}{HTTP}
\scnexplanation{SCTP представляет собой \textit{бинарный протокол}, позволяющий осуществлять операции чтения (поиска) и редактирования конструкций, хранящихся в sc-памяти, а также отслеживать события, происходящие в sc-памяти.

Взаимодействие между клиентом и сервером на протоколе SCTP осуществляется путем обмена \textit{sctp-командами}, каждая из которых представляет собой набор байт, предназначенный для машинной обработки (но не восприятия человеком).
}

\scnheader{sctp-команда}
\scnrelfromset{обобщенная декомпозиция}{заголовок sctp-команды\\
	\scnaddlevel{1}
		\scnidtf{часть sctp-команды, в которой указан её тип и некоторая дополнительная информация о ней}
	\scnaddlevel{-1}
	;аргументы sctp-команды\\
	\scnaddlevel{1}
		\scnidtf{часть sctp-команды, которая содержит её аргументы и размер которой может быть разным в зависимости от типа команды.}
	\scnaddlevel{-1}}
\scnrelfromlist{включение;пример}{sctp-команда удаления sc-элемента с указанным sc-адресом;sctp-команда создания нового sc-узла указанного типа;sctp-команда получения начального и конечного элемента sc-дуги}
\scnnote{Выполнение каждой sctp-команды предполагает наличие sctp-результата, однозначно соответствующего данной команде.}

\scnheader{SCTP}
\scntext{программная документация}{http://ostis-dev.github.io/sc-machine/net/sctp/}
\scnrelfromlist{недостаток}{\scnfileitem{Команды протокола SCTP являются низкоуровневыми (ориентированы на работу с единичными sc-элементами или простейшими sc-конструкциями из 3 или 5 элементов). Это приводит к тому, что выполнение даже несложного преобразования в базе знаний или ассоциативный поиск по набору взаимосвязанных конструкций выражаются в виде достаточно большого набора sctp-команд. С учетом того, что для каждой команды существует sctp-результат, также пересылаемый по сети, это излишне нагружает сеть и сильно ухудшает производительность системы в целом. Кроме того, производительность системы начинает сильно зависеть от пропускной способности сети.};
\scnfileitem{Протокол SCTP по аналогии с протоколом HTTP предполагает четкое разделение активного клиента и пассивного сервера, который отвечает на запросы клиентов. Таким образом, сервер (в данном случае -- sc-память) не имеет возможности по своей инициативе отправить сообщение клиенту, что повышает безопасность системы, но значительно снижает ее интерактивность. Кроме того, такой вариант реализации затрудняет реализацию принятого в Технологии OSTIS многоагентного подхода, в частности, затрудняет реализацию sc-агентов на стороне клиента. Указанные проблемы могут быть решены путем постоянного мониторинга определенных событий со стороны клиента, однако такой вариант неэффективен.};
\scnfileitem{Протокол SCTP не предназначен для восприятия человеком}
}
\scnrelfromlist{достоинство}{\scnfileitem{Протокол SCTP является кросс-платформенным};\scnfileitem{Протокол SCTP может быть достаточно просто реализован практически на любом языке программирования}}

\scnheader{Реализация подсистемы взаимодействия с внешней средой с использованием протокола SCTP}

\scnheader{Реализация подсистемы взаимодействия с внешней средой с использованием протоколов на основе формата JSON}

\scnheader{Реализация вспомогательных инструментальных средств в рамках реализации sc-памяти}
\scnrelfrom{компонент программной системы}{Реализация сборщика базы знаний из исходных текстов, записанных в SCs-коде}

\scnheader{Реализация сборщика базы знаний из исходных текстов, записанных в SCs-коде}
\scnidtf{sc-builder}

\scnheader{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\scnrelfromlist{используемый язык программирования}{JavaScript;TypeScript;Python}

\scnheader{Реализация scp-интерпретатора}
\scnrelfromlist{используемый язык программирования}{C++}

\scnendstruct

\end{SCn}